---
title: Subgraphs overview
sidebarTitle: Subgraphs
---

import AlphaCallout from '/snippets/alpha-lg-callout.mdx';

<AlphaCallout />

A subgraph is a [graph](/oss/langgraph/graph-api#graphs) that is used as a [node](/oss/langgraph/graph-api#nodes) in another graph â€” this is the concept of encapsulation applied to LangGraph. Subgraphs allow you to build complex systems with multiple components that are themselves graphs.

:::python
![Subgraph](/oss/images/subgraph.png)
:::

Subgraphs are useful for:

* Building [multi-agent systems](/oss/langchain/multi-agent)
* When you want to reuse a set of nodes in multiple graphs
* When you want different teams to work on different parts of the graph independently, you can define each part as a subgraph, and as long as the subgraph interface (the input and output schemas) is respected, the parent graph can be built without knowing any details of the subgraph

The main question when adding subgraphs is how the parent graph and subgraph communicate, i.e. how they pass the [state](/oss/langgraph/graph-api#state) between each other during the graph execution. There are two scenarios:

* Parent and subgraph have **shared state keys** in their state [schemas](/oss/langgraph/graph-api#state). In this case, you can [include the subgraph as a node in the parent graph](/oss/langgraph/use-subgraphs#shared-state-schemas)

    :::python
    ```python {highlight={12,17}}
    from langgraph.graph import StateGraph, MessagesState, START

    # Subgraph

    def call_model(state: MessagesState):
        response = model.invoke(state["messages"])
        return {"messages": response}

    subgraph_builder = StateGraph(State)
    subgraph_builder.add_node(call_model)
    ...
    subgraph = subgraph_builder.compile()

    # Parent graph

    builder = StateGraph(State)
    builder.add_node("subgraph_node", subgraph)
    builder.add_edge(START, "subgraph_node")
    graph = builder.compile()
    ...
    graph.invoke({"messages": [{"role": "user", "content": "hi!"}]})
    ```
    :::
    :::js
    ```typescript {highlight={13,18}}
    import { StateGraph, MessagesZodMeta, START } from "@langchain/langgraph";
    import { registry } from "@langchain/langgraph/zod";
    import * as z from "zod";

    const MessagesZodState = z.object({
        messages: z
        .array(z.custom<BaseMessage>())
        .register(registry, MessagesZodMeta),
    });

    // Subgraph

    const subgraphBuilder = new StateGraph(MessagesZodState).addNode(
        "callModel",
        async (state) => {
        const response = await model.invoke(state.messages);
        return { messages: response };
        }
    );
    // ... other nodes and edges
    const subgraph = subgraphBuilder.compile();

    // Parent graph

    const builder = new StateGraph(MessagesZodState)
        .addNode("subgraphNode", subgraph)
        .addEdge(START, "subgraphNode");
    const graph = builder.compile();
    // ...
    await graph.invoke({ messages: [{ role: "user", content: "hi!" }] });
    ```
    :::

* Parent graph and subgraph have **different schemas** (no shared state keys in their state [schemas](/oss/langgraph/graph-api#state)). In this case, you have to [call the subgraph from inside a node in the parent graph](/oss/langgraph/use-subgraphs#different-state-schemas): this is useful when the parent graph and the subgraph have different state schemas and you need to transform state before or after calling the subgraph
    :::python
    ```python {highlight={7,11,19,28}}
    from typing_extensions import TypedDict, Annotated
    from langchain_core.messages import AnyMessage
    from langgraph.graph import StateGraph, MessagesState, START
    from langgraph.graph.message import add_messages

    class SubgraphMessagesState(TypedDict):
        subgraph_messages: Annotated[list[AnyMessage], add_messages]

    # Subgraph

    def call_model(state: SubgraphMessagesState):
        response = model.invoke(state["subgraph_messages"])
        return {"subgraph_messages": response}

    subgraph_builder = StateGraph(SubgraphMessagesState)
    subgraph_builder.add_node("call_model_from_subgraph", call_model)
    subgraph_builder.add_edge(START, "call_model_from_subgraph")
    ...
    subgraph = subgraph_builder.compile()

    # Parent graph

    def call_subgraph(state: MessagesState):
        response = subgraph.invoke({"subgraph_messages": state["messages"]})
        return {"messages": response["subgraph_messages"]}

    builder = StateGraph(State)
    builder.add_node("subgraph_node", call_subgraph)
    builder.add_edge(START, "subgraph_node")
    graph = builder.compile()
    ...
    graph.invoke({"messages": [{"role": "user", "content": "hi!"}]})
    ```
    :::
    :::js
    ```typescript {highlight={5,11,17,22}}
    import { StateGraph, MessagesZodMeta, START } from "@langchain/langgraph";
    import { BaseMessage } from "@langchain/core/messages";
    import { registry } from "@langchain/langgraph/zod";
    import * as z from "zod";

    const MessagesZodState = z.object({
    messages: z
        .array(z.custom<BaseMessage>())
        .register(registry, MessagesZodMeta),
    });

    const SubgraphState = z.object({
    subgraphMessages: z
        .array(z.custom<BaseMessage>())
        .register(registry, MessagesZodMeta),
    });

    // Subgraph

    const subgraphBuilder = new StateGraph(SubgraphState)
    .addNode("callModelFromSubgraph", async (state) => {
        const response = await model.invoke(state.subgraphMessages);
        return { subgraphMessages: response };
    })
    .addEdge(START, "callModelFromSubgraph");
    // ...
    const subgraph = subgraphBuilder.compile();

    // Parent graph

    const builder = new StateGraph(MessagesZodState)
    .addNode("subgraphNode", async (state) => {
        const response = await subgraph.invoke({
        subgraphMessages: state.messages,
        });
        return { messages: response.subgraphMessages };
    })
    .addEdge(START, "subgraphNode");
    const graph = builder.compile();
    // ...
    await graph.invoke({ messages: [{ role: "user", content: "hi!" }] });
    ```
    :::
